/*
 * Copyright 2012 simplelib.org
 * 
 * This file is part of SimplePersist.
 * 
 * SimplePersist is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SimplePersist is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with SimplePersist. If not, see <http://www.gnu.org/licenses/>.
 */

package org.simplelib.simplepersist.dao;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Connection class.
 * 
 * @author simplelib.org
 */
public final class AccesBdd {
    static final Logger LOGGER = Logger.getLogger("dao");
    /** Properties file path with access data. */
    private static final String PROPERTIES = "db.properties";
    /** Avalaible databases list. */
    private static List<Database> dbList = new ArrayList<AccesBdd.Database>();
    /** Current database. */
    private static Database currentDb;
    /** Auto-connection. */
    private static boolean autoConnect = true;

    static class Database {
	private final DatabaseType TYPE;
	private Connection dbConnection;
	// Database cache
	private static Map<String, Database> dbMap = new HashMap<String, AccesBdd.Database>();

	private Database(DatabaseType type) {
	    this.TYPE = type;
	}

	private static Database valueOf(String url, String user, String password)
		throws SQLException {
	    Database db;
	    if (dbMap.containsKey(url)) {
		db = dbMap.get(url);
	    } else {
		db = new Database(DatabaseType.extractFrom(url));
		dbMap.put(url, db);
	    }
	    if (db.dbConnection == null || db.dbConnection.isClosed()) {
		db.dbConnection = DriverManager.getConnection(url, user,
			password);
	    }
	    return db;
	}

	protected void close() throws SQLException {
	    if (this.dbConnection.getAutoCommit() == false) {
		this.dbConnection.commit();
	    }
	    this.dbConnection.close();
	}

	DatabaseType getType() {
	    return TYPE;
	}

	private Connection getConnection() {
	    return dbConnection;
	}
    }

    static enum DatabaseType {
	MYSQL("INTEGER AUTO_INCREMENT"), POSTGRESQL("SERIAL"), STANDARD_SQL(
		"INTEGER GENERATED BY DEFAULT AS IDENTITY");

	private DatabaseType(String automaticKey) {
	    AUTOMATIC_KEY = automaticKey;
	}

	private final String AUTOMATIC_KEY;

	void appendAutomaticKey(Appendable app, String field)
		throws IOException {
	    app.append(field);
	    app.append(' ');
	    app.append(AUTOMATIC_KEY);
	}

	private static DatabaseType extractFrom(String url) {
	    String dbName = url.substring(5).toLowerCase();
	    if (dbName.startsWith("mysql")) {
		return DatabaseType.MYSQL;
	    } else if (dbName.startsWith("postgresql")) {
		return DatabaseType.POSTGRESQL;
	    }
	    // USING STANDARDIZED SQL SYNTAX
	    else {
		return DatabaseType.STANDARD_SQL;
	    }
	}
    }

    static Database currentDb() {
	ensureDbConnection();
	return currentDb;
    }

    /**
     * Connect to a Database.
     * 
     * @param url
     *            Database url.
     * @param user
     *            User name.
     * @param pwd
     *            Password.
     * @throws SQLException
     *             Connection error.
     */
    public static void connect(String url, String user, String pwd)
	    throws SQLException {
	currentDb = Database.valueOf(url, user, pwd);
	if (!dbList.contains(currentDb)) {
	    dbList.add(currentDb);
	}
    }

    public static void connect(String propSource) throws SQLException {
	if (!propSource.endsWith(".properties")) {
	    propSource += ".properties";
	}
	Properties propFile = loadProperties(propSource);
	String url = propFile.getProperty("url");
	String user = propFile.getProperty("user");
	String password = propFile.getProperty("password");
	connect(url, user, password);
    }

    /** Disable autoconnection with properties file on first database access. */
    public void disableAutoconnect() {
	AccesBdd.autoConnect = false;
    }

    /** Disable autoconnection with properties file on first database access. */
    public void enableAutoconnect() {
	AccesBdd.autoConnect = true;
    }

    /**
     * Déconnecte le serveur de toutes les BDD.
     * 
     * @throws Exception
     *             En cas d'erreur SQL.
     */
    public static void close() {
	for (Database db : dbList) {
	    Connection con = db.getConnection();
	    if (con != null) {
		try {
		    currentDb.getConnection().close();
		} catch (Exception e) {
		    LOGGER.severe("Problème de déconnection du serveur !");
		    throw new RuntimeException(e);
		}
	    }
	}
    }

    /**
     * Checked {@link Statement} close.
     * 
     * @param stmt
     *            {@link Statement} to close.
     */
    static void closeStatement(final Statement stmt) {
	try {
	    if (stmt != null) {
		stmt.close();
	    }
	} catch (SQLException e) {
	    // Erreur non blocante.
	    e.printStackTrace();
	    LOGGER.severe("Erreur lors de la fermeture du statement");
	}
    }

    private static Properties loadProperties(String source) {
	Properties propBD = new Properties();
	InputStream in = null;
	try {
	    in = ClassLoader.getSystemResourceAsStream(source);
	    propBD.load(in);
	} catch (Exception e) {
	    LOGGER.severe("Impossible de lire le fichier " + "properties: "
		    + PROPERTIES);
	    throw new RuntimeException(e);
	} finally {
	    if (in != null) {
		try {
		    in.close();
		} catch (IOException e) {
		    throw new RuntimeException(e);
		}
	    }
	}
	return propBD;
    }

    private static void ensureDbConnection() {
	if (currentDb == null || currentDb.getConnection() == null) {
	    if (autoConnect) {
		// AUTOCONNECT
		try {
		    connect(PROPERTIES);
		} catch (SQLException e) {
		    LOGGER.severe("Impossible d'établir la connexion à la base de données.");
		    throw new RuntimeException(e);
		}
	    }
	}
    }

    /**
     * Renvoie l'instance de connection après l'avoir créée si ce n'était pas
     * déjà fait ou si la connection était fermée.
     * 
     * @return L'instance de connexion.
     * @throws Exception
     *             En cas d'erreur de connection.
     */
    public static Connection getConnection() {
	ensureDbConnection();
	Connection conn = currentDb.getConnection();
	if (conn == null) {
	    throw new IllegalStateException("No database connection avalaible.");
	}
	return conn;
    }

    /**
     * Crée un PreparedStatement basé sur la requête SQL fournie.
     * 
     * @return Le PreparedStatement.
     * @param req
     *            La requête SQL.
     * @throws Exception
     *             En cas d'erreur SQL.
     */
    static PreparedStatement getPreparedStatement(final String req) {
	try {
	    return AccesBdd.getConnection().prepareStatement(req);
	} catch (SQLException e) {
	    LOGGER.severe("Impossible d'obtenir un PreparedStatement !");
	    throw new RuntimeException(e);
	}
    }

    /**
     * Crée un PreparedStatement basé sur la requête SQL fournie.
     * 
     * @return Le PreparedStatement.
     * @param req
     *            La requête SQL.
     * @throws Exception
     *             En cas d'erreur SQL.
     */
    static PreparedStatement getPreparedStatementWithGenKeys(final String req) {
	try {
	    return AccesBdd.getConnection().prepareStatement(req,
		    Statement.RETURN_GENERATED_KEYS);
	} catch (SQLException e) {
	    LOGGER.severe("Impossible d'obtenir un PreparedStatement !");
	    throw new RuntimeException(e);
	}
    }

    /**
     * Fournit directement un Statement pour l'envoi direct d'une requète SQL.
     * 
     * @return Un Statement.
     * @throws Exception
     *             En cas d'erreur SQL.
     */
    static Statement getStatement() {
	try {
	    return AccesBdd.getConnection().createStatement();
	} catch (Exception e) {
	    LOGGER.severe("Impossible d'obtenir un Statement !");
	    throw new RuntimeException(e);
	}
    }

    /**
     * Execute a batch of SQL commands.
     * 
     * @param file
     *            Path of SQL file to execute.
     * @throws Exception
     */
    public static void executeBatch(final String file) {
	Statement stmt = null;
	try {
	    InputStream in = new BufferedInputStream(
		    ClassLoader.getSystemResourceAsStream(file));
	    StringBuilder sql = new StringBuilder();
	    int i;
	    while ((i = in.read()) != -1) {
		sql.append((char) i);
	    }
	    in.close();
	    stmt = getStatement();

	    String[] queries = sql.toString().split(";");
	    // On élimine la dernière chaine car elle ne correspond pas à une
	    // requête.
	    int max = queries.length - 1;
	    for (i = 0; i < max; ++i) {
		if (queries[i].trim().isEmpty()) {
		    LOGGER.info("Requête vide : ignorée.");
		} else {
		    LOGGER.log(Level.FINEST, queries[i]);
		    stmt.addBatch(queries[i]);
		}
	    }
	    stmt.executeBatch();
	} catch (Exception e) {
	    LOGGER.severe("L'execution de la requête a échouée.");
	    throw new RuntimeException(e);
	} finally {
	    closeStatement(stmt);
	}
    }

    /** Private constructor to forbidden instanciation. */
    private AccesBdd() {
    }
}
